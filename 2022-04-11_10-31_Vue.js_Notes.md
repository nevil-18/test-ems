- What is the Vue CLI Service?
- The Vue CLI Service is a run-time dependency (@vue/cli-service) that abstracts webpack and provides default configurations. It can be upgraded, configured and extended with plugins.

- It provides multiple scripts for working with Vue projects, such as the serve, build and inspect scripts.

- We’ve seen the serve and build scripts in action already. The inspect script allows you to inspect the webpack config in a project with vue-cli-service.

Vue 2: Vue 2 sports excellent performance stats, a relatively small payload (the bundled runtime version of Vue weighs in at 30KB once minified and gzipped), along with updates to companion libraries like vue-router and Vuex, the state management library for Vue. There’s far too much to cover in just one article, but keep an eye out for some later articles where we’ll look more closely at various libraries that couple nicely with the core framework.

- Package.json - Dependencies
- public/index.html - VueJs app renders
- src/main.js - is where the magic hapens, this is where we write our vue.js code and where we put the assets used in our VueJS code

*What is Vue Component: A component is a self-contained, reusable, most often single-responsibility, piece of UI logic. Components are reusable Vue instnace with custom HTLM elements Components can be reused as many times as you want or used in another component, making it a child component. Data, computed, watch, and methods can be used in a Vue component. A webpage is made up of different components*

- *What is Vue instance is essentially a ViewModel as defined in the MVVM pattern. hence the variable name vm you will see throughout the docs. When you instantiate a Vue instance, you need to pass in an options object which can contain options for data, template, element to mount on, methods, lifecycle callbacks and more*

28-03-2022

- *v-model:Create a relationship between the data in the instance/component and a form input, so you can dynamically updates value*
- To capture form inputs/differences between v-model inputs or textareas or things like that very quickly it's called "Two-way Binding".  
- Binding input values with v-model
- We can bind form input and textarea element values to the Vue instance data using the v-model directive. According to the Vue docs, the v-model directive enables you 
  to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type.

- v-model.trim will strip any leading or trailing whitespace from the bound string
- v-model.number changes strings to number inputs
- v-model.lazy won't populate the content automatically, it will wait to bind until an event happens. (it listens to change events instead of input)

<script>
new Vue({
  el: '#app',
  data: {
    form : {
      name: ''
    }
  }
})
</script>

In the above code, we define the data option in our Vue instance and define a form object, which will hold all the properties we want for our form. The first property we define is name, which is bound to the text input we also created.
Now that two-way binding exists, we can use the value of form.name anywhere in our application, as it will be the updated value of the text input. We can add a section to view all the properties of our form object
Note that v-model will ignore the value, checked, or selected attributes of form inputs and will treat the Vue instance data as the source of truth. This means that you can also specify a default value for form.name in the Vue instance. That is what the initial value of the form input will be.

Textarea example
These work the same way regular input boxes work, It’s important to note that interpolation in textarea  —  <textarea>{{ form.message}}</textarea> — will not work for two-way binding. Use the v-model directive instead
Using the v-model directive for select boxes
The v-model directive can also be easily plugged in for select boxes. The defined model will be synced with the value of the selected option,
<select v-model="form.inquiry_type">
<option disabled value="">Nothing selected</option>
<option v-for="option in options.inquiry" v-bind:value="option.value">
{{ option.text }}
</option>
</select>
data: {
form : {
name: '',
message: '',
inquiry_type: '' // single select box value
},
options: {
inquiry: [
{ value: 'feature', text: "Feature Request"},
{ value: 'bug', text: "Bug Report"},
{ value: 'support', text: "Support"}
]
}
}
In the above code, we chose to load the options dynamically using the v-for directive. This requires us to also define the available options in the Vue instance

The process is similar for a multi-select box. The difference is that the selected values for the multi-select box are stored in an array.
<select multiple v-model="form.logrocket_usecases">
<option>Debugging</option>
<option>Fixing Errors</option>
<option>User support</option>
</select>
data: {
form : {
name: '',
message: '',
inquiry_type: '',
logrocket_usecases: [], // multi select box values
},
// ..
} In the example above, the selected values will be added to the logrocket_usecases array.

Checkbox example: Single checkboxes which require a boolean (true/false) value can be implemented like this,
<label class="checkbox">
<input type="checkbox" v-model="form.terms">
I agree to the <a href="#">terms and conditions</a>
</label>
data: {
form : {
name: '',
message: '',
inquiry_type: '',
logrocket_usecases: [],
terms: false,
concepts: [], // multiple checkbox values
},
// ..
} The value of form.terms in the example above will either be true or false depending on whether the checkbox is checked or not. A default value of false is given to the property, hence the initial state of the checkbox will be unchecked.

For multiple checkboxes, they can simply be bound to the same array:

 <div class="control">
    <label class="checkbox">
      <input type="checkbox" v-model="form.concepts"
        value="promises">
      Promises
    </label> 
    <label class="checkbox">
      <input type="checkbox" v-model="form.concepts" 
        value="testing">
      Testing
    </label>
  </div>
  
data: {
  form : {
    name: '',
    message: '', 
    inquiry_type: '', 
    logrocket_usecases: [],
    terms: false,
    concepts: [], // multiple checkbox values
  }, 
  // ..
}

Radio Button: For the radio button the v-model property takes the value of the selected radio button
<label class="radio">
<input v-model="form.js_awesome" type="radio" value="Yes">
Yes
</label>
<label class="radio">
<input v-model="form.js_awesome" type="radio" value="Yeap!">
Yeap!
</label>

Validating user inputs with vee-validate, while writing custom validation loig is possible, there is already a great plugin that helps validate esaily and displays the corresponding errors. this plugin is vee-validate. his form validation library for Vue.js allows you to validate inputs and build form UIs in a declarative style, or using composition functions. First, we need to include the plugin in our app. This can be done with yarn or npm, To set up the plugin, we will place this just right above our Vue instance:
Vue.use(VeeValidate); <input name="name" 
      v-model="form.name" 
      v-validate="'required|min:3'" 
      class="input" type="text" placeholder="Full name">
In the above example, we defined two rules: the first is that the name field is required (required), the second is that the minimum length of any value typed in the name field should be three (min:3)

Tip: Rules can be defined as objects for more flexibility. For example: v-validate=”{required: true, min: 3}”

To access the errors when these rules aren’t passed, we can use the errors helper object created by the plugin. For example, to display the errors just below the input, we can add this:

<p class="help is-danger" v-show="errors.has('name')">
  {{ errors.first('name') }}
</p> In the code above, we take advantage of a couple of helper methods from the vee-validate plugin to display the errors:
.has() helps us check if there are any errors associated with the input field passed in as a parameter. It returns a boolean value (true/false).
.first() returns the first error message associated with the field passed in as a parameter.
Other helpful methods include .collect(), .all(), and .any()

Creating custom validation rules with Validator.extend(): We can create custom rules using the Validator.extend() method. Your custom rules must adhere to a contract or a certain structure
Let’s add a validation method that forces our users to be polite when sending messages:

VeeValidate.Validator.extend('polite', {
getMessage: field => `You need to be polite in the ${field} field`,
validate: value => value.toLowerCase().indexOf('please') !== -1
});
Our validator consists of two properties:

getMessage(field, params): Returns a string — the error message when validation fails.
validate(value, params): Returns a boolean, object, or promise. If a boolean isn’t returned, the valid(boolean) property needs to be present in the object or promise.
vue-validate was also built with localization in mind. You can view notes on translation and localization in the full vue-validate custom rules docs.

Form submission with event handler: to handle form submissions, we can make use of Vue's submit event handler. For method event handlers, we'll use the v-on method, We can also plug in the .prevent modifier to prevent the default action, which in this case would be the page refreshing when the form is submitted:
...

<form v-on:submit.prevent="console.log(form)"> 
  ...
  <div class="field is-grouped">
    <div class="control">
      <button class="button is-primary">Submit</button>
    </div>
  </div>
</form>
...
In the above example, we simply log the entire form model to the console on form submission. We can add one final touch with vee-validate to make sure that users aren’t allowed to submit an invalid form. We can achieve this using errors.any():
<button 
  v-bind:disabled="errors.any()"
  class="button is-primary">
  Submit
</button>
In the above code, we disable the submit button once any errors exist in our form.

V-IF / V-SHOW
Is a conditional that will display information depending on meeting a requirement. This can be anything- buttons, forms, divs, components.

V-IF/V-ELSE
Pretty straightforward- you can conditionally render one thing or another. There's also v-else-if Must be siblings.

V-BIND: or : One of the most useful directives so there's a shortcut! We can use it for so many things- class and style binding, creating dynamic props, etc...

V-FOR Loops through a set of values, Can also do a static number, Needs to be unique, it's what Vue uses to track VDOM changes <li v-for="num in 5" :key="num">

V-ONCE and V-PRE
Not quite as useful, v-once will not update once it's been rendered.
v-pre will print out the inner text exactly how it is, including code (good for documentation)

V-ON or @ Extremely useful so there's a shortcut! v-on is great for binding to events like click and mouseenter. You're able to pass in a parameter for the event like (e), We can also use ternaries directly

Warnings: Not the same as templates: inserted as plain HTML don't use on user-rendered content, avoid XSS atacks

MULTIPLE BINDINGS

<div v-on/@="
  mousedown: doThis,
  mouseup: doThat
"> </div>

MODIFIERS @mousemove.stop is comparable to e.stopPropagation()
@mousemove.prevent this is like e.preventDefault()
@submit.prevent this will no longer reload the page on submission
@click.once not to be confused with v-once, this click event will be triggered once.
@click.native so that you can listen to native events in the DOM
Keycodes (using names instead of numbers as of 3.x)

V-HTML Great for strings that have html elements that need to be rendered!

V-TEXT Similar to using mustache templates
Warning: If you want to dynamically update, it's recommended to use mustache templates instead

Methods computed in watchers
Methods: Are bound to the Vue instance, they are incredibly useful for functions you would like to access in directives.
But Sarah, say functions that you'd like to access in directives because that's a pretty interesting part of it. But they're functions that you can access in any part, you can access them in lifecycle hooks, in other methods or even in computed properties.

So let's go over methods, they're really aptly named because when you look at the view instance and the Options API, that data is really an object. So far what we've have been working with in data is just one big object. And methods are a function that hangs off of the view instance object. So they're very aptly named in this case.

And when we say this inside of a method, we're always referring to data (this.counter++)

Twitter Post (JS): I get really frustraed with JavaScript and I wanna scream! This is bullshit, but I keep forgetting what this refers to.

codePen E.g :- e.clientX which means that I'm tracking where it is lying across the page. That event is like, where is my mouse in terms of the pixels across on this page(codepen e.g) and mapping that to this.x, So Sarah says this.x is equal to e.clientx
Style binding, Bgcolor, & I'm passing in this is a Template literal and Sarah is passing that "x" into the bgc: 'hsl(${x}, 80%, 50%)'

\*Note: In JS if you wanna make generative colors, let's say you wanna do some creative coding or something "Hue" values are really good for this generative color thing, whereas with hex values or RGB, you eventually have something that fails on either side of negative or positive.
Hue is a big circle, so you can keep going around and around in the circle. using "h" to create different values as i go across the screen with this "h", So I'm v-binding that style.

V-directive shortcut " : " for bind and " @ " for event.

Forms E.g: "@submit.prevent" this prevent modifier is going to do that "e.preventDefault" so it's gonna keep that form from reloading the page on submission. So we've got @submit.prevent, and we're gonna call a method called "submitForm".
Using axios.post, and posting to this JSONplaceholder. We also did that binding of that ternary to turn on an active class " :class="[name ? activeclass : '']", using this to create that relationship and say the active class is active. .active has a bgcolor of primary. Means when data is entered then only button will be active else not.
first post things, response: "" a empty string, then we say this.response = JSON.stringify(response, null, 2 - spaces),
-> this.binding is really important we wanna establish a relationship with these properties in "this". We can't use an arrow function here, on the method because that would not create that binding, we can use an arrow function once we're inside of that method, but it would lose the this.binding if we started to use an arrow function at this top level. Sort titles by sort lowest, sort highest, we loop throguh keys, columns ratings info then that outputs to the page.

_COMPUTED_, properties are calculations that will be cached, & will only be update when needed.
-> "Highly performant but use with understanding" Computed properties are so powerful
e.g userData-input, & The computed property is giving us a new view onto that data, So data is not mutated or I'm not changing user data in any way. But I'm able to do something with user data and return a different value of it. And the greeting in will only be recalculated or re-evaluated if this.userData changes so it's really really performant.

differece between computed and methods;
computed:

- Runs only when a dependency has changed
- Cached
- Should be used as a property, in place of data
  -By default getter only, but you can define a setter

Methods:

- Runs whenever an update occurs
- Not cached
- Typically invoked from v-on/@, but flexible
- Getter/setter

-> Using computed property in place of the data, we now have a different view of the data.

-> Difference in Vue2 & Vue3 FILTERS: (we can perform all this things with computed properties & methods)

- Vue is not so different from Vue 2, in that the surface api is the same.
- There few minor differences one is that we deprecated "filters"
- Composition API which is an additive new feature, that's an advanced feature

Customizing Component v-model: by default, v-model on a component uses value as prop and input as the event, but some input types such as chekboxes and radio buttons may want to use the value atribute for a different purpose. Using the model option can avoid a conflict in such cases.

29/03/2022 Meeting
camelCase, Template, script, Style should be in format,
lifecycle hooks:
created()
dom before created
mounted(before) redner
updated(before) updated
destroyed()

30/03/2022
Vue's application design is inspired by the MVVM pattern. As a convention, we have to use the variable vm (short for ViewModel) to refer to our Vue instance. When you create a Vue instance, you have to pass in an options object. In this article, you will learn how you can use these options to create your desired behavior.

A Vue application contains a root Vue instance created with a new Vue. It is organized into a tree of nested and reusable components.

Note\* All Vue components are also the Vue instances

In example we have used a parameter called el. This "el" parameter is used to carry the id of the DOM element. In the above example, we have the id #app. It is the id of the div element presented in the Index.html fil

After defining the id, we have defined the data object. In the data object, we have defined some values such as firstname, and lastname. This is also defined inside the <div>
element. For example,

<div id = "app">  
   <h1>Firstname : {{firstname}}</h1>  
   <h1>Lastname : {{lastname}}</h1>  
</div>

Vue Instance Lifecycle Hooks
Every Vue instance goes through a series of initialization steps. When you create an instance, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. This process is known as the lifecycle of a Vue instance.

Explanation of Vue Instance Lifecycle Hooks
Following is the list of all events or hooks a Vue instance goes through. There are eight lifecycle events/methods or hooks for Vue.js Instance Lifecycle:

Before create hook
Created hook
Before mount hook
Mounted hook
Before update hook
Updated hook
Before destroy hook
Destroyed hook

beforeCreate() hook: The beforeCreate() hook is the first event or hook that occurs in the creation process. It facilitates developers to perform actions even before the component has been added to the DOM. We cannot access the DOM inside of this event. In this hook, the data is still not reactive and events that occur during the component's lifecycle have not been set up yet.

31/03/2022

- In vue if we want to show a tip or something that's slightly different from the original value, I would use a pipe " | " special char. is called "pipe". Thn I would say filters and I would parse in the value and then I'd return [value*.2].toFixed(2).
  Which would yield this tip Calculator that has the total and it's 20%, and then it shows what that value is. This was in Vue 2.

Same output with computed properties.
And the reason why it's important to deprecate features like this that you can actually do the same thing in, is we wanted to make Vue3 SuperSmall. Vue 3 is really, really tiny comparatively and it offers really great performance. And part of the reason is that we're making sure that surface area of the API is slendered

-> We're not able to pass parameter in "computed" that is tied with customer1total tipApp, but we can do that with methods.

- Computed properties and methods can be used for filter purpose.
- Other examples that you might use computer properties for, are adding currency signs.

- More Complex: Filtering large amounts of data based on user Input
- Creating Data visualizations you can explore

-> WHAT IS REACTIVE: "Reactive programming is programming with asynchronous data streams"

- A stream is a sequence of ongoing events ordered in time that offer some hooks with which to observer it.
- E.g if you have a hover state that had some transition on it, there's the movement that you start hovering on it. There's the transition state in which it's changing. And then there's that end
  state and you have hoks with which to observe this part, the transition part, the end part.

-> when we use reactive premises for building application, this means it's very easy to update state in reaction to events.

- RxJs is reactive programming
- But reactive programming is a type of programming it's a large umbrella and "RxJs" is one library that uses reactive premises.
- Angular and Vue uses reactive premises mobX uses reactive premises

- How would we make something reactive, How does Vue3 do this:
- Detect when there’s a change in one of the values
- Track the function that changes it
- Trigger the function so it can update the final value

-> PROXIES: in JS are a newer feature

- In vue 2, we use object defined property which is an, it predates ESX, it's ES5

- Proxies are ES6 (previously Object.defineProperty)

- An object that encases another object or function and allows you to intercept it.
  new Proxy(target, handler)

- E.g const dinner = {
  meal: 'tacos'
  }
      cosnt handler = {
       get(target, prop) {
        return target[prop]  1 way
        track(target, prop) //track in vue (Saves any Changes)
        return Reflect.get(...arguments)
        //REFLECT Binds "this" properly
        //Track the things that are changing
- We could intercept and say, okay, I want to still return that. But I also want to track the properties that are changing. I want to make sure that i have a function that's collecting that imformation, and I'm gona call it "TRACK"  
   }
  }
  const proxy = new Proxy(dinner, handler)
  console.log(proxy.meal)
  //output tacos
- "Trigger" in vue "Runs the changes"
  const handler = {
  get(target, prop, receiver) {
  track(target, prop)
  return Reflect.get(...arguments)
  },
  set(target, key, value, receiver) {
  trigger(target, key)
  return Reflect.set(...arguments)
  }
  }

- We don't have to detect when there's a change in one of the values. Because proxies are already doing that for us automatically. We can track the function that changes it using track and we can trigger a function that updates the final value in trigger.

- Base concepts: Set(), Map(), WeakMap():
- SET() - A Set is a series of only values, (similar to an array), where any particular value can only be inserted once.

- MAP() - A Map is a series of keys and values, similar to an object, but with some differences:

- Key/value pairs remember their explicit ordering
  Performs better in scenarios involving frequent additions and removals
- Like Set(), you can only add key/value pairs once
- It has some nice methods, like size, has, set, clear, delete(key)

- WEAKMAP()
- Similar to a Map(), but the references are held weakly. In other words, if you delete something, the reference can be garbage collected
  (in a Map() it can’t)

* this also means it loses the implicit ordering, it also loses some methods e.g. "set".

- the difference is literally that one can be garbage collected and one can't(map).

- When you pass an object a Vue instance as data, Vue converts it to a proxy.
- This proxy enables vue to perform dependency-tracking and change-notification when properties are accessed or modified
- There are two levels of dependencies for every component.
- The first level uses a Map() and stores the dependencies for each property
- Thesecond level tracks the effects which will be run when the values change
- After the first render, a component would have tracked a list of dependencies -- The properties it accessed during the render.
- Conversely, the component becomes a subscriber to each of these properties
- When a proxy intercepts a set operation, the property will notify all of its subscribed components to re-render
- Vue reactivity efficiently tracks changes in our application

- WATCHERS: Good for asynchronous updates, and updates/transition with data changes.

- So unlike in computed properties, where we have a different name for different type of data and those have to be different.

- We also have access to the new value and the old value: We can also gain access to nested values with 'deep':

- watch: {
  watchedProperty (newValue, oldValue) {
  //your dope code here
  }
  },
  watch: {
  watchedProperty {
  deep: true,
  nestedWatchedProperty (newValue, oldValue) {
  //your dope code here
  }
  }
  },

Sarah recommend that always encapsulating things and methods and calling them so that it's a little bit more explicit and not doing everything directly in the watcher in order to kind of change things around

- API: Application programming interfaces, or APIs, simplify software development and innovation by enabling applications to exchange data and functionality easily and securely.

- An API enables communication to open up their applications data and functionality to external third-arty developers, business partenr and internal departments within thier companies. This allows srevices and products to communicate with each other and levrage each other's data and functionality through a documentend interface. Developers don't need to know how an API is implemented; they simply use the interface to communicate with other products and services. API use has surged over the past decade, to the degree that many of the most popular web applications today would not be possible without APIs.

- TEMPLATES

- Vue.js uses HTML-based template syntax to bind the Vue instance to the DOM, very useful for components.
- Templates are optional, you can also write render functions with optional JSX support.
- We will start with strings (only useful for small cases) and then to script, and then to single-file templates in the next section.
- Templates are optional, you can also write render functions with optional JSX support
- We will start with strings (only useful for small cases) and then to script, and then to single-file templates in the next section (Sarah Drasner)

- COMPONENTS
- “Components are a collection of elements that are encapsulated into a group that can be accessed through a single element.” – Sarah Drasner
- Components help us make a chunk of code reusable. This means whenever we need a functionality which has previously been implemented, we do not need to repeat 
  the same chunk of code over again to replicate such functionality.
- Slots and props help us achieve this by making it easy to dynamically change the content of components

* "VUE is a progressive framework, so we support incremental adoption"

- Replacing jQuery with Vue, no build step necessary, Smashing

- PROPS: Passing data down from the parent to the child, props: ['text']
- Props are intended for one way communication
- You can think of it a little like the component holds a variable that is waiting to be filled out by whatever the parent sends down to it.
- In simple terms, props are openings within a component that are filled with data. This means that when a component has a prop, it expects to get data from 
  another component or view within which it is imported. This other component could be called the parent component.
- 

* We use v-bind or :to dynamically bind props to data on the parent

- PROPS TYPE & VALIDATION:
  app.component('app-child', {
  props: {
  text: {
  type: String,
  required: true,
  default: 'hello mr. magoo'
  }
  },
  template: `<div>{{ text }}<div>`
  });

* Objects and arrays need their defaults to be returned from a function
  text: {
  type: Array,
  default: function () {
  return ['al pastor', 'carne asada']
  } }
- You don't need to necessarily pass the data in props to the child, either, you have the option of using vue instance data or a static value as you see fit.
- Not using the state of the parent <child count="1"></child>
  vs
- Using the state of the parent <child :count="count"></child>

- { Each component instance has its own isolated scope data must be a function }
- It used to be in VUE2 that you could write data as an object and not a function and then it wouldn't have its own isolated scope.
- But it'll error now, In VUE 3 we just say data must be a function.

- camelCasing will be converted props: ['booleanValue']
- In HTML it'll be kebab-case: <checkbox :boolean-value="booleanValue"> </checkbox> (So it will convert boolean values to kebab case, it'll make sure that's there line here)
- This is cool bcoz in js a lot of times we want to use camel casing, that's typical thing we do in JS is use camel casing for values. vue knows that in HTML we don't use camel cases values. 
- "booleanValue" works in js but it html it converts automatically to kebab case ":boolean-value"
 
- COMMUNICATING EVENTS with emit: Emit is a way to tell, report, activity from the child to the parent. So far, we're doing props down, we're explaining everything from the parent has all the control and it's telling the child about things. 
- Now if child want to reports its duties to parent, Well the child doesn't cahnge it, right? We're not mutating that prop on the child. We're communicating to the parent, hey, something changed and the parent will go up, and update.

- WHY? we need this; One way flow of data so there is only one source of truth.
- This is one way to do it, we will explore other cases with Vuex and Composition API, we don't want multiple things happening all over the place that are totally different from one an other.
- we wan to make sure that we really have just one thing that we're working with here and that it's getting doled out to other places. Emit is one of doing it. 'Compostion API' is another way of doing it. "VueX" is another way of doing this.    

* $emit - The child is reporting it's activity to the parent

* Sp when I click this emits, this changes to taco.When you see sign "$" that's something vue instance has in particular,that has to offer us.
* Emit dosen't have to be passed through that clickHandler, we can say *this.emit* inside a function if we want t do more functionality there    .
- So in methods we have, on the updateTaco this.text. So the parent is making that change, event though the button was clicked on the child.
- So parent is making that change eventhough the button was clicked on the child. But the parent is the one changing it, not the child.  

* Is it a bad practice to pass function into a child, so that the parent component would have access to the scope of the parent?
* You can pass that kind of data around, although when using VueX and Compostion API we're gonna see how there's lot more available to us. 
- If you're going to add more functionlaity start using things like *VueX or Composition API*. Because you just have a lot more that you can work with, you're
  not passing a huge amounr of information around.  

- SLOTS - Pass some content into a component with ease!
- So far we've been passing props and saying like, okay render this thing by passing props.But there are instances where you just need to render a little bit
  of content differently. So you can pass some content into a component with ease. It's just waiting there for that content. 
- So a modal is a pretty good example of this. Typically with a modal, you've got something that is going to always function. Typically, with a modal, you've
  got something that is going to always function similarly where it's got a certain presentation style, it's gonna open, it's gonna close, but what's inside of it might change, right?
- The way that you're using that model might change because you want different content 
- E.g you're "signed in" 
* Template *v-slot* is new, that's not how we used to work with it in V2.
- It's a way for us we used to use scoped slots slightly differently than regular slots, and there's a merging of this to make it a little bit more simple. 
- MORE: SCOPED SLOTS

- *:is* extra directive allows us to use dynamic component.

- Ex. Vue wine Label Maker: So when we have  selected at black, the component is going to be whatever I selected here, & have v-modal that allows me to select
  appBlack or appWhite and switch out that component based on which one I want. So now we can pass all of that into a slot and we can also changes all of these pieces based on that directive. 

- Mentioned before that we could do component is selected and we can pass in whatever we want and we can switch out compoennts as we see fit, which is really
  nice. we also have available to us this thing called keep-alive that you can wrap our component in.

- KEEP-ALIVE: can create dynamic components that remember themselves quite easily.
- It's saying remember which one I had selected, Remember things dynamically bond. 
- E.g 3 text dog, cake, car onlick the other content will be displayed when keep-alive is there, but when keep-alive is deleted it will mounting & unmounting
  it doesn't remember which one you selected.     

- The simple way of writing props, you can name props the same thing.

- VUE CLI, WHY would we use a CLI to build our projects instead of kind of adding a CDN and creaing these script templates? 
> Build processes that allows us to use great features like ES6, or SCSS, easy to use other libraries
> We're gonna build and concatenate single file templates, which are awesome (not biased)
> And we don't wanna load all of our files on startup, but sometimes we want to kind of lazy where we have the ability to lazy load components, especially in
  Nuxt it's really easy as well.
> Server-Side rendering, code-splitting, performance metrics 
> Build/prod versions 

> REACTIVE: It can automatically refresh your data, modern app.need to render data dynamically in various HTML elements.
> REACTIVITY: in a framework is a declarative programming model that takes care of keeping the DOM in sync with the updates to current state  

- SINGLE FILE TEMPLATES 
- VUE FILES MEAN NO CONTEXT-SHIFTING!
- H - word - HyperScript 
- Nuxt is a metaframework but it is a framework on top of Vue. It's like Vue's version of Next. 
- So React has Next, Vue has Nuxt
- Originated in India, Engine: upto 1497cc, Transmission: Auto/Manual, Seating Capacity: 5, Mileage: 18/23 kmpl combined
- https://ptcnews-wp.s3.ap-south-1.amazonaws.com/wp-content/uploads/2020/11/Altroz.jpg
- Punch: Made in India, Engine: 1199cc, Transmission: Auto/Manual, Seating Capacity: 5, Mileage: 18.97 kmpl 

*What are Props in Vue.js?*
> “Props” is a special keyword which stands for properties. It can be registered on a component to pass data from a parent component to one of its children components.
> This is a lot easier compared to using state management libraries like vuex for Vue.js applications.
> Data in props can only flow one way – from the top, or parent component, to the bottom, or child components. This simply means you cannot pass data from a child to a
  parent.
> Another thing to keep in mind is that Props are read-only and cannot be modified by the child component because the parent component "owns" that value.
> Let’s balance things up now – the parent components pass props to the child component(s) while the child component emit events to the parent component(s).
> You can have more than one prop by appending them to the props array, just like this:
    Vue.component('user-detail', {
      props: ['firstName', 'lastName'],
      template: '<p>Hi {{ firstName }} {{ lastName }}</p>'
    })

> *Vue.js Prop Types*
> To specify the type of prop you want to use in Vue, you will use an object instead of an array. You'll use the name of the property as the key of each property, and 
  the type as the value.
> If the type of the data passed does not match the prop type, Vue sends an alert (in development mode) in the console with a warning. The valid types you can use are:
> String, Number, Boolean, Array, Object, Date, Function, Symbol

> *Note: you can also use a ternary operator inside the prop value to check a truthy condition and pass a value that depends on it.*
> 

*ReactJS VS VueJS*
> If you're coming from React you're used to passing down functions all of the time.
> In React you'll pass a function from a parent to a child component, so the child can communicate back up to the parent. Props and data flow down, and function calls
  flow up.
> Vue, however, has a different mechanism for achieving child -> parent communication.
> This works in the same way that the DOM works — providing a little more consistency with the browser than what React does. Elements can emit events, and these events 
  can be listened too.
> So even though it can be tempting to pass functions as props in Vue, it's considered an anti-pattern.
> *Using Events in Vue:* 
> Events are how we communicate to parent components in Vue.
> Here is a short example to illustrate how events work.
> In summary, we use props to pass down data from the parent components to the child component(s). The child component also emit events to the parent component(s) in 
  case you need to send data/events from the child to the parent component

*Using scoped slots instead*
> Scoped slots are a more advanced topic, but they are also incredibly useful.
> In fact, I would consider them to be one of the most powerful features that Vue offers.
> They let you blur the lines between what is in the child's scope and what is in the parent's scope. But it's done in a very clean way that leaves your components as 
  composable as ever.

> *Accessing a parent's scope from the child component:* In many cases the problem you are trying to solve is accessing values from different scopes.
> The parent component has one scope, and the child component another.
> Often you want to access a value in the child component from the parent, or access a value in the parent component from the child.
> Vue prevents us from doing this directly, which is a good thing.
> It keeps our components more encapsulated and promotes their reusability. This makes your code cleaner and prevents lots of headaches in the long run.
> But you may be tempted to try and pass functions as props to get around this.
> We use events in Vue.

# VueX
- At the center of every Vuex application is the store. A "store" is basically a container that holds your application state. There are two things that make a Vuex 
  store different from a plain global object:
  
  1. Vuex stores are reactive. When Vue components retrieve state from it, they will reactively and efficiently update if the store's state changes.
  2. You cannot directly mutate the store's state. The only way to change a store's state is by explicitly committing mutations. This ensures every state change leaves 
     a track-able record, and enables tooling that helps us better understand our applications.




9998887158

*Notes Hiren Dhaduk Meeting*

> Stay Positive for any task, Yes MAN
> Be Honest and discipline, about leave/outing mention proper reason and working
> Better Communication
> 3 things to keep in mind while implementing something 1.Reading solutions on google about any problem, 2.taking opinion of seniors/manager, 3.implement accordingly.
> Contiouns Testing really important, Always do production ready implementation.
> Do push code frequently or atleast 1/3 times a day, else when leaves taken of 1 or 2 day how other will support your work,when their is not latest code pushed
> Product *realiability* very important can be evaluated in percentage
> 

*VueJS Call Notes-*
> 15/04/2022: VueJS SPA, tutsfinder website e.g, Parent to Child props passing example, 
> this.$emit, emit v-on:click = $emit(values) 
> api call before pageDisplay - mounted or created
> Methods ar always in camescase
> Use props and events, Available soon.

*Task to be completed before next Call:*
> props Data Passing 
> Edit form data autofill Done! 
> Validations and Available Soon Cars: Button Disabled 
> Read about: Array, v-for/each, filter and methods related array and conditional, es6: let, const

*Monthly Update Review and Concerns & Weekly Team Meeting:*
> April Q2 2022 GraphQL & Unit Testing (Zest), Evening Status update with tag!
> May 10 1st Team Meeting, May 17 @nd 